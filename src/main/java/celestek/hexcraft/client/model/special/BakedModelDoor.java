package celestek.hexcraft.client.model.special;

import java.util.List;
import java.util.Optional;

import javax.vecmath.Matrix4f;

import org.apache.commons.lang3.tuple.Pair;

import com.google.common.collect.Lists;

import celestek.hexcraft.utility.HexShapes;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
import net.minecraft.client.renderer.block.model.ItemOverrideList;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.renderer.vertex.VertexFormat;
import net.minecraft.util.BlockRenderLayer;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.client.MinecraftForgeClient;
import net.minecraftforge.client.model.PerspectiveMapWrapper;
import net.minecraftforge.common.model.IModelState;
import net.minecraftforge.common.model.TRSRTransformation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * A baked model of a special frame which uses 1 texture and door half which uses 2 textures for the front and rear sides. The frame is rendered on the solid layer while the door - on the translucent layer.
 * The model changes depending on the extra tags parsed by the {@link ModelDoor}. Also supports quad caching and perspective and matrix transforms
 */
@SideOnly(Side.CLIENT)
public class BakedModelDoor implements IBakedModel
{
	/**
	 * A cache key used to store different quads of the model
	 */
	/*
	private class CacheKey
	{
		protected BakedModelDoor model;
		protected IBlockState state;
		protected BlockRenderLayer renderLayer;

		public CacheKey(BakedModelDoor model, IBlockState state, BlockRenderLayer renderLayer)
		{
			this.model = model;
			this.state = state;
			this.renderLayer = renderLayer;
		}

		@Override
		public boolean equals(Object o)
		{
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			CacheKey key = (CacheKey) o;
			return this.state == key.state && this.renderLayer == key.renderLayer; // Careful with this comparison in case block states are changed and are no longer compared like this
		}

		@Override
		public int hashCode()
		{
			int hash = this.state != null ? this.state.hashCode() : 0;
			hash = 31 * hash + (this.renderLayer != null ? this.renderLayer.hashCode() : 0);
			return hash;
		}
	}

	private static final LoadingCache<CacheKey, List<BakedQuad>> CACHE = CacheBuilder.newBuilder().build(new CacheLoader<CacheKey, List<BakedQuad>>()
	{
		@Override
		public List<BakedQuad> load(CacheKey key)
		{
			List<BakedQuad> quads = Lists.newArrayList();
			if(key.renderLayer == null || key.renderLayer == BlockRenderLayer.SOLID) HexShapes.Frame.create(quads, key.model.format, key.model.transform, key.model.edge, null, 0, false, key.model.base);
			if(key.renderLayer == null || key.renderLayer == BlockRenderLayer.TRANSLUCENT) HexShapes.Door.create(quads, key.model.format, key.model.transform, key.model.flip, key.model.edge, null, -1, true, key.model.front, key.model.side);
			return quads;
		}
	});
	*/

	/**
	 * The item perspective transforms defined under the "transform" tag in the blockstate
	 */
	protected final IModelState state;
	/**
	 * The vertex format in which all of the model's quads should be drawn in
	 */
	protected final VertexFormat format;
	/**
	 * The matrix transforms generated by {@link ModelDoor}
	 */
	protected final Optional<TRSRTransformation> transform;
	protected final int flip, edge;

	protected final TextureAtlasSprite base, front, side;

	public BakedModelDoor(IModelState state, VertexFormat format, TextureAtlasSprite base, TextureAtlasSprite front, TextureAtlasSprite side, Optional<TRSRTransformation> transform, int flip, int edge)
	{
		this.state = state;
		this.format = format;
		this.base = base;
		this.front = front;
		this.side = side;
		this.transform = transform;
		this.flip = flip;
		this.edge = edge;
	}

	@Override
	public List<BakedQuad> getQuads(IBlockState state, EnumFacing side, long rand) // Culling?
	{
		List<BakedQuad> quads = Lists.newArrayList();
		// Don't drawing anything if faces should be culled
		if(side != null) return quads;
		BlockRenderLayer renderLayer = MinecraftForgeClient.getRenderLayer();
		// Draw the quads
		// Render the frame part if on the solid layer
		if(renderLayer == null || renderLayer == BlockRenderLayer.SOLID) HexShapes.Frame.create(quads, this.format, this.transform, this.edge, side, 0, false, this.base);
		// Render the door part if on the translucent layer
		// Also do not mirror the textures if already open and vice versa
		if(renderLayer == null || renderLayer == BlockRenderLayer.TRANSLUCENT) HexShapes.Door.create(quads, this.format, this.transform, this.flip, this.edge, side, -1, true, this.front, this.side);
		return quads;
	}

	@Override
	public boolean isAmbientOcclusion()
	{
		return false;
	}

	@Override
	public boolean isGui3d()
	{
		return true;
	}

	@Override
	public boolean isBuiltInRenderer()
	{
		return false;
	}

	@Override
	public TextureAtlasSprite getParticleTexture()
	{
		return this.front;
	}

	@Override
	public ItemOverrideList getOverrides()
	{
		return ItemOverrideList.NONE;
	}

	@Override
	public Pair<? extends IBakedModel, Matrix4f> handlePerspective(TransformType transform)
	{
		return PerspectiveMapWrapper.handlePerspective(this, this.state, transform);
	}
}