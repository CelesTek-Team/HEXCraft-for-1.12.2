package celestek.hexcraft.client.model.special;

import java.util.List;
import java.util.Optional;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Lists;

import celestek.hexcraft.utility.HexShapes;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.block.model.ItemOverrideList;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.renderer.vertex.VertexFormat;
import net.minecraft.util.BlockRenderLayer;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.client.MinecraftForgeClient;
import net.minecraftforge.common.model.TRSRTransformation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * A baked model of a special frame which uses 1 texture and door half which uses 2 textures for the front and rear sides. The frame is rendered on the solid layer while the door - on the translucent layer.
 * The model changes depending on the extra tags parsed by the {@link ModelDoor}. Also supports quad caching
 */
@SideOnly(Side.CLIENT)
public class BakedModelDoor implements IBakedModel
{
	/**
	 * A cache key used to store different quads of the model
	 */
	private class CacheKey
	{
		protected BakedModelDoor model;
		protected IBlockState state;
		protected BlockRenderLayer renderLayer;

		public CacheKey(BakedModelDoor model, IBlockState state, BlockRenderLayer renderLayer)
		{
			this.model = model;
			this.state = state;
			this.renderLayer = renderLayer;
		}

		@Override
		public boolean equals(Object o)
		{
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			CacheKey key = (CacheKey) o;
			return this.state == key.state && this.renderLayer == key.renderLayer; // Careful with this comparison in case block states are changed and are no longer compared like this
		}

		@Override
		public int hashCode()
		{
			int hash = this.state != null ? this.state.hashCode() : 0;
			hash = 31 * hash + (this.renderLayer != null ? this.renderLayer.hashCode() : 0);
			return hash;
		}
	}

	private static final LoadingCache<CacheKey, List<BakedQuad>> CACHE = CacheBuilder.newBuilder().build(new CacheLoader<CacheKey, List<BakedQuad>>()
	{
		@Override
		public List<BakedQuad> load(CacheKey key)
		{
			List<BakedQuad> quads = Lists.newArrayList();
			if(key.renderLayer == null || key.renderLayer == BlockRenderLayer.SOLID) HexShapes.Frame.create(quads, key.model.format, key.model.transform, key.model.top, null, 0, false, key.model.base);
			if(key.renderLayer == null || key.renderLayer == BlockRenderLayer.TRANSLUCENT) HexShapes.Door.create(quads, key.model.format, key.model.transform, key.model.top, key.model.open != key.model.flip, null, -1, true, key.model.front, key.model.side);
			return quads;
		}
	});

	/**
	 * The vertex format in which all of the model's quads should be drawn in
	 */
	protected final VertexFormat format;
	/**
	 * The matrix transforms generated by {@link ModelDoor}
	 */
	protected final Optional<TRSRTransformation> transform;
	protected final boolean open, flip, top;

	protected final TextureAtlasSprite base, front, side;

	protected boolean enableCache = true;

	public BakedModelDoor(VertexFormat format, TextureAtlasSprite base, TextureAtlasSprite front, TextureAtlasSprite side, Optional<TRSRTransformation> transform, boolean open, boolean flip, boolean top)
	{
		this.format = format;
		this.base = base;
		this.front = front;
		this.side = side;
		this.transform = transform;
		this.open = open;
		this.flip = flip;
		this.top = top;
	}

	public BakedModelDoor setCache(boolean flag)
	{
		this.enableCache = flag;
		return this;
	}

	@Override
	public List<BakedQuad> getQuads(IBlockState state, EnumFacing side, long rand) // Culling?
	{
		List<BakedQuad> quads = Lists.newArrayList();
		// Don't drawing anything if faces should be culled
		if(side != null) return quads;
		BlockRenderLayer renderLayer = MinecraftForgeClient.getRenderLayer();
		// Draw the quads
		if(this.enableCache) return CACHE.getUnchecked(new CacheKey(this, state, renderLayer));
		else
		{
			// Render the frame part if on the solid layer
			if(renderLayer == null || renderLayer == BlockRenderLayer.SOLID) HexShapes.Frame.create(quads, this.format, this.transform, this.top, side, 0, false, this.base);
			// Render the door part if on the translucent layer
			if(renderLayer == null || renderLayer == BlockRenderLayer.TRANSLUCENT) HexShapes.Door.create(quads, this.format, this.transform, this.top, this.open != this.flip, side, -1, true, this.front, this.side);
		}
		return quads;
	}

	@Override
	public boolean isAmbientOcclusion()
	{
		return false;
	}

	@Override
	public boolean isGui3d()
	{
		return true;
	}

	@Override
	public boolean isBuiltInRenderer()
	{
		return false;
	}

	@Override
	public TextureAtlasSprite getParticleTexture()
	{
		return this.front;
	}

	@Override
	public ItemOverrideList getOverrides()
	{
		return ItemOverrideList.NONE;
	}
}